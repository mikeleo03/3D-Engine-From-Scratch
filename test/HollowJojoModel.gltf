{"buffers":[{"uri":"data:application/octet-stream;base64,AAAgwgAAIMIAAHBBAAAgwgAAIMIAAHDBAAAgQgAAIMIAAHBBAAAgQgAAIMIAAHDBAAAAAAAAIEIAAHBBAAAAAAAAIEIAAHDBAADIwQAAyMEAAHBBAADIwQAAyMEAAHDBAADIQQAAyMEAAHBBAADIQQAAyMEAAHDBAAAAAAAAyEEAAHBBAAAAAAAAyEEAAHDBAAABAAIAAgABAAMAAQAAAAQAAQAEAAUAAgADAAQABAADAAUABwAGAAgABwAIAAkABgAHAAoACgAHAAsACQAIAAoACgALAAkAAAAGAAQABgAKAAQACAACAAQACgAIAAQAAAAIAAYAAAACAAgABwABAAUABwAFAAsAAwAJAAUACQALAAUAAwABAAcAAwAHAAkAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACALvlkvy755D4AAAAALvlkvy755D4AAAAALvlkvy755D4AAAAALvlkvy755D4AAAAALvlkvy755D4AAAAALvlkvy755D4AAAAALvlkPy755D4AAAAALvlkPy755D4AAAAALvlkPy755D4AAAAALvlkPy755D4AAAAALvlkPy755D4AAAAALvlkPy755D4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAALvlkPy755L4AAAAALvlkPy755L4AAAAALvlkPy755L4AAAAALvlkPy755L4AAAAALvlkPy755L4AAAAALvlkPy755L4AAAAALvlkvy755L4AAAAALvlkvy755L4AAAAALvlkvy755L4AAAAALvlkvy755L4AAACALvlkvy755L4AAACALvlkvy755L4AAACAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAgAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/mg6QvnYQMr5Ml3E/Iswdv10Mw75AbDC/5IiqPqoHFL/jqT4/5IiqPqoHFL/jqT4/Iswdv10Mw75AbDC/xwwDP1h+97wDx1u/Iswdv10Mw75AbDC/mg6QvnYQMr5Ml3E/AAAAAOsF0T7psWk/Iswdv10Mw75AbDC/AAAAAOsF0T7psWk/AAAAAIN0Xz6W1Hm/5IiqPqoHFL/jqT4/xwwDP1h+97wDx1u/AAAAAOsF0T7psWk/AAAAAOsF0T7psWk/xwwDP1h+97wDx1u/AAAAAIN0Xz6W1Hm/6KvKPgiEej75l2K/mg6QPnYQMj5Ml3E/ZfZQvvRitT6NoGk/6KvKPgiEej75l2K/ZfZQvvRitT6NoGk/xwwDv1h+9zwDx1u/mg6QPnYQMj5Ml3E/6KvKPgiEej75l2K/AAAAAKuqKr+nzz4/AAAAAKuqKr+nzz4/6KvKPgiEej75l2K/AAAAAOsF0b7psWm/xwwDv1h+9zwDx1u/ZfZQvvRitT6NoGk/AAAAAKuqKr+nzz4/AAAAAKuqKr+nzz4/AAAAAOsF0b7psWm/xwwDv1h+9zwDx1u/mg6QvnYQMr5Ml3E/mg6QPnYQMj5Ml3E/AAAAAOsF0T7psWk/mg6QPnYQMj5Ml3E/AAAAAKuqKr+nzz4/AAAAAOsF0T7psWk/ZfZQvvRitT6NoGk/5IiqPqoHFL/jqT4/AAAAAOsF0T7psWk/AAAAAKuqKr+nzz4/ZfZQvvRitT6NoGk/AAAAAOsF0T7psWk/mg6QvnYQMr5Ml3E/ZfZQvvRitT6NoGk/mg6QPnYQMj5Ml3E/mg6QvnYQMr5Ml3E/5IiqPqoHFL/jqT4/ZfZQvvRitT6NoGk/6KvKPgiEej75l2K/Iswdv10Mw75AbDC/AAAAAIN0Xz6W1Hm/6KvKPgiEej75l2K/AAAAAIN0Xz6W1Hm/AAAAAOsF0b7psWm/xwwDP1h+97wDx1u/xwwDv1h+9zwDx1u/AAAAAIN0Xz6W1Hm/xwwDv1h+9zwDx1u/AAAAAOsF0b7psWm/AAAAAIN0Xz6W1Hm/xwwDP1h+97wDx1u/Iswdv10Mw75AbDC/6KvKPgiEej75l2K/xwwDP1h+97wDx1u/6KvKPgiEej75l2K/xwwDv1h+9zwDx1u/","byteLength":2016}],"bufferViews":[{"buffer":0,"byteOffset":0,"byteLength":144,"target":34962},{"buffer":0,"byteOffset":288,"byteLength":864,"target":34962},{"buffer":0,"byteOffset":1152,"byteLength":864,"target":34962},{"buffer":0,"byteOffset":144,"byteLength":144,"target":34963}],"accessors":[{"bufferView":0,"byteOffset":0,"componentType":5126,"count":12,"type":"VEC3","max":[],"min":[]},{"bufferView":1,"byteOffset":0,"componentType":5126,"count":72,"type":"VEC3","max":[],"min":[]},{"bufferView":2,"byteOffset":0,"componentType":5126,"count":72,"type":"VEC3","max":[],"min":[]},{"bufferView":3,"byteOffset":0,"componentType":5123,"count":72,"type":"SCALAR","max":[],"min":[]}],"samplers":[],"images":[],"textures":[],"materials":[{"type":"Basic Material","name":"Hollow Triangle","vertexShader":"\n#define PI 3.1415926535897932384626433832795\nattribute vec4 a_position;\n\nuniform mat4 u_worldMatrix;\nuniform mat4 u_viewMatrix;\nuniform vec4 u_color;\n\nvarying vec4 v_color;\n\nvoid main() {    \n    gl_Position = u_viewMatrix * u_worldMatrix * a_position;\n    v_color = u_color;\n}\n","fragmentShader":"\nprecision highp float;\nvarying vec4 v_color;\n\nvoid main() {\n    gl_FragColor = v_color / 255.0;\n}\n","uniforms":{"color":[52,25,0,255]}},{"type":"Phong Material","name":"Hollow Triangle-phong","vertexShader":"\nprecision mediump float;\n\nattribute vec3 a_position;\nattribute vec3 a_faceNormal;\nattribute vec3 a_vertexNormal;\nattribute vec2 a_displacementUV;\nattribute vec2 a_diffuseUV;\nattribute vec2 a_specularUV;\nattribute vec2 a_normalUV;\nattribute vec3 a_tangent;\nattribute vec3 a_bitangent;\n\nuniform mat4 u_worldMatrix;\nuniform mat4 u_viewMatrix;\nuniform sampler2D u_displacementMap;\nuniform float u_displacementScale;\nuniform float u_displacementBias;\n\nvarying vec3 normalSurface;\nvarying vec3 vertexPosition;\nvarying vec2 diffuseUV;\nvarying vec2 specularUV;\nvarying mat3 v_tbn;\nvarying vec2 v_texcoord;\nvarying vec3 v_pos;\n\nvoid main() {\n    vec4 displacement = texture2D(u_displacementMap, a_displacementUV);\n\n    vec4 displacementVector = normalize(vec4(a_vertexNormal.xyz, 0.0)) * (displacement.r * u_displacementScale + u_displacementBias);\n\n    vec4 vertexPosition4 = u_worldMatrix * (vec4(a_position, 1.0) + displacementVector);\n    vertexPosition = vec3(vertexPosition4) / vertexPosition4.w;\n    normalSurface = (u_viewMatrix * u_worldMatrix * vec4(a_faceNormal, 1.0)).xyz;\n    diffuseUV = a_diffuseUV;\n    specularUV = a_specularUV;\n    \n    vec3 T = normalize(vec3(u_worldMatrix * vec4(a_tangent, 0.0)));\n    vec3 B = normalize(vec3(u_worldMatrix * vec4(a_bitangent, 0.0)));\n    \n    vec3 normalTemp = cross(a_tangent, a_bitangent);\n    vec3 N = normalize(vec3(u_worldMatrix * vec4(normalTemp, 0.0)));\n\n    v_tbn = mat3(T, B, N);\n    v_texcoord = a_normalUV;\n    v_pos = a_position;\n    \n    gl_Position = u_viewMatrix * vertexPosition4;\n}\n","fragmentShader":"\nprecision mediump float;\n\n// Tecture sampler\nuniform sampler2D u_diffuseMap;\nuniform sampler2D u_specularMap;\nuniform sampler2D u_normalMap;\nuniform bool u_hasNormalMap;\nuniform float u_hasDiffuseMap;\nuniform float u_hasSpecularMap;\n\n// Material uniform\nuniform float u_shininess;\nuniform vec4 u_ambientColor;\nuniform vec4 u_diffuseColor;\nuniform vec4 u_specularColor;\n\n// Light uniform\nuniform int u_numLights;\n\n// Light properties\nuniform float u_lightType_0;\nuniform vec3 u_lightPosition_0;\nuniform vec4 u_lightColor_0;\nuniform vec4 u_lightAmbient_0;\nuniform vec4 u_lightDiffuse_0;\nuniform vec4 u_lightSpecular_0;\nuniform vec3 u_lightTarget_0;\nuniform float u_lightConstant_0;\nuniform float u_lightLinear_0;\nuniform float u_lightQuadratic_0;\n\nuniform float u_lightType_1;\nuniform vec3 u_lightPosition_1;\nuniform vec4 u_lightColor_1;\nuniform vec4 u_lightAmbient_1;\nuniform vec4 u_lightDiffuse_1;\nuniform vec4 u_lightSpecular_1;\nuniform vec3 u_lightTarget_1;\nuniform float u_lightConstant_1;\nuniform float u_lightLinear_1;\nuniform float u_lightQuadratic_1;\n\nuniform float u_mode;\n\nvarying vec3 normalSurface;\nvarying vec3 vertexPosition;\nvarying vec2 diffuseUV;\nvarying vec2 specularUV;\n\nvarying mat3 v_tbn;\nvarying vec2 v_texcoord;\n\nvoid main() {\n    vec3 N;\n    \n    if (u_hasNormalMap) {\n      N = texture2D(u_normalMap, v_texcoord).rgb;\n      N = N * 2.0 - 1.0;\n      N = normalize(v_tbn * N);\n    } else {\n      N = normalize(normalSurface);\n    }\n    \n    vec3 finalAmbient = vec3(0.0);\n    vec3 finalDiffuse = vec3(0.0);\n    vec3 finalSpecular = vec3(0.0);\n\n    // Convert colors from 0-255 to 0-1\n    vec3 ambientColor = u_ambientColor.rgb / 255.0;\n    vec3 diffuseColor = u_diffuseColor.rgb / 255.0;\n    vec3 specularColor = u_specularColor.rgb / 255.0;\n\n    for (int i = 0; i < 2; i++) {\n        vec3 L;\n        if (i == 0 && u_lightType_0 == 0.0) {\n            // Directional Light\n            L = normalize(u_lightTarget_0 - vertexPosition);\n        } else if (i == 1 && u_lightType_1 == 0.0) {\n            // Directional Light\n            L = normalize(u_lightTarget_1 - vertexPosition);\n        } else if (i == 0 && u_lightType_0 == 1.0) {\n            // Point Light\n            L = normalize(u_lightPosition_0 - vertexPosition);\n        } else {\n            // Point Light\n            L = normalize(u_lightPosition_1 - vertexPosition);\n        }\n\n        vec3 lightAmbient = (i == 0) ? (u_lightAmbient_0.rgb / 255.0) : (u_lightAmbient_1.rgb / 255.0);\n        vec3 lightDiffuse = (i == 0) ? (u_lightDiffuse_0.rgb / 255.0) : (u_lightDiffuse_1.rgb / 255.0);\n        vec3 lightSpecular = (i == 0) ? (u_lightSpecular_0.rgb / 255.0) : (u_lightSpecular_1.rgb / 255.0);\n\n        // Lambert's cosine law\n        float lambertian = max(dot(N, L), 0.0);\n        float specular = 0.0;\n        if (lambertian > 0.0) {\n            vec3 R = reflect(-L, N);       // Reflected light vector\n            vec3 V = normalize(-vertexPosition);  // Vector to viewer\n            \n            // Compute the specular term\n            float specAngle = max(dot(R, V), 0.0);\n            specular = pow(specAngle, u_shininess);\n        }\n\n        // Directional light calculation\n        vec3 directionalAmbient = lightAmbient * ambientColor;\n        vec3 directionalDiffuse = lightDiffuse * lambertian * diffuseColor;\n        vec3 directionalSpecular = lightSpecular * specular * specularColor;\n\n        // Point light calculation 1\n        float distance1 = length(u_lightPosition_0 - vertexPosition);\n        float attenuation1 = 1.0 / (u_lightConstant_0 + u_lightLinear_0 * distance1 + u_lightQuadratic_0 * distance1 * distance1);\n\n        vec3 pointAmbient1 = attenuation1 * lightAmbient * ambientColor;\n        vec3 pointDiffuse1 = attenuation1 * lightDiffuse * lambertian * diffuseColor;\n        vec3 pointSpecular1 = attenuation1 * lightSpecular * specular * specularColor;\n\n        // Point light calculation 2\n        float distance2 = length(u_lightPosition_1 - vertexPosition);\n        float attenuation2 = 1.0 / (u_lightConstant_1 + u_lightLinear_1 * distance2 + u_lightQuadratic_1 * distance2 * distance2);\n\n        vec3 pointAmbient2 = attenuation2 * lightAmbient * ambientColor;\n        vec3 pointDiffuse2 = attenuation2 * lightDiffuse * lambertian * diffuseColor;\n        vec3 pointSpecular2 = attenuation2 * lightSpecular * specular * specularColor;\n\n        // Processing by u_mode\n        // Mode 1 : 1st Directional, 2nd Point\n        if (u_mode == 1.0) {\n            if (i == 0) {\n                finalAmbient += directionalAmbient;\n                finalDiffuse += directionalDiffuse;\n                finalSpecular += directionalSpecular;\n            } else if (i == 1) {\n                finalAmbient += pointAmbient2;\n                finalDiffuse += pointDiffuse2;\n                finalSpecular += pointSpecular2;\n            }\n        }\n        // Mode 2 : 1st Point, 2nd Directional\n        else if (u_mode == 2.0) {\n            if (i == 0) {\n                finalAmbient += pointAmbient1;\n                finalDiffuse += pointDiffuse1;\n                finalSpecular += pointSpecular1;\n            } else if (i == 1) {\n                finalAmbient += directionalAmbient;\n                finalDiffuse += directionalDiffuse;\n                finalSpecular += directionalSpecular;\n            }\n        }\n        // Mode 3 : 1st Directional, 2nd None\n        else if (u_mode == 3.0 && i == 0) {\n            finalAmbient += directionalAmbient;\n            finalDiffuse += directionalDiffuse;\n            finalSpecular += directionalSpecular;\n        }\n        // Mode 4 : 1st Point, 2nd None\n        else if (u_mode == 4.0) {\n            finalAmbient += pointAmbient1;\n            finalDiffuse += pointAmbient1;\n            finalSpecular += pointAmbient1;\n        }\n    }\n\n    // Using texture sampler\n    vec3 fixedDiffuse = finalDiffuse;\n    if (u_hasDiffuseMap == 1.0) {\n        fixedDiffuse = fixedDiffuse * texture2D(u_diffuseMap, diffuseUV).rgb;\n    }\n\n    vec3 fixedSpecular = finalSpecular;\n\n    if (u_hasSpecularMap == 1.0) {\n        fixedSpecular = finalSpecular * texture2D(u_specularMap, specularUV).rgb;\n    }\n\n    vec3 finalColor = finalAmbient + fixedDiffuse + fixedSpecular;\n    gl_FragColor = vec4(finalColor, 1.0);\n    \n}\n","uniforms":{"ambientColor":[52,25,0,255],"diffuseColor":[204,102,0,255],"specularColor":[255,255,255,255],"shininess":60,"diffuseMaps":[],"normalMaps":[],"displacementMaps":[],"specularMaps":[],"diffuseMap":-1,"normalMap":-1,"displacementMap":-1,"specularMap":-1}}],"meshes":[{"primitives":[{"attributes":{"POSITION":0,"FACE_NORMAL":1,"VERTEX_NORMAL":2},"basicMaterial":0,"phongMaterial":1,"indices":3}]}],"cameras":[],"lights":[],"nodes":[{"id":"64562992-753c-4e15-aae4-a8c036984b1d","name":"Hollow Triangle","translation":[0,0,0],"rotation":[0,1,0,6.123233995736766e-17],"scale":[1,1,1],"children":[],"mesh":0}],"scenes":[{"nodes":[0],"activeCamera":-1,"activeLight":[-1]}],"animations":[{"name":"kosong","frames":[{"nodeKeyframePairs":[{"node":0,"keyframe":{"scale":[1,0.5,1]}}]},{"nodeKeyframePairs":[{"node":0,"keyframe":{"scale":[1,0,1]}}]},{"nodeKeyframePairs":[{"node":0,"keyframe":{"scale":[1,0.5,1]}}]},{"nodeKeyframePairs":[{"node":0,"keyframe":{"scale":[1,1,1]}}]},{"nodeKeyframePairs":[{"node":0,"keyframe":{"scale":[1,0.5,1]}}]},{"nodeKeyframePairs":[{"node":0,"keyframe":{"scale":[1,0,1]}}]},{"nodeKeyframePairs":[{"node":0,"keyframe":{"scale":[1,0.5,1]}}]},{"nodeKeyframePairs":[{"node":0,"keyframe":{"scale":[1,1,1]}}]}]}],"scene":0}